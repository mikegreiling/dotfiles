#!/usr/bin/env bash
# tmux-resurrect user options persistence - RESTORE
#
# Restores user options captured during save.
# Invoked via: @resurrect-hook-pre-restore-pane-processes
#
# Hook Timing Rationale:
#   This hook runs AFTER panes/windows are created but BEFORE processes start.
#
#   Why this matters:
#   1. Panes must exist for us to set options on them
#   2. Metadata must be available before processes that depend on it start
#      Example: Claude Code reading @claude_session when it launches
#   3. Uses documented API (vs undocumented @resurrect-hook-post-restore-all)
#
# Safety Guarantees:
#   - NEVER overwrites existing user option values
#   - Validates pane identity using CWD before restoration
#   - Continues on individual errors (doesn't abort entire restoration)
#   - Silently skips panes that don't exist or have wrong CWD
#
# Restoration Logic:
#   For each pane in sidecar file:
#     1. Check if pane exists at session:window.pane index
#     2. Check if user option already exists (skip if yes - never overwrite)
#     3. Validate CWD matches saved value (skip if no - wrong pane due to renumbering)
#     4. Set user option (ignore errors, continue to next)
#
# This mirrors tmux-resurrect's behavior: restore to panes it creates/modifies,
# skip panes that already existed or were renumbered.
#
# Expected TSV format (7 tab-separated fields per line):
#   scope session window pane key value_b64 cwd
#
#   Example: pane	main	1	0	@claude_session	dGVzdDEyMw==	/Users/mike/projects
#
# See useropts-save script header for complete format documentation.

set -euo pipefail

# Match tmux-resurrect's XDG-aware default directory:
res_dir="$(tmux show -gv @resurrect-dir 2>/dev/null || echo "${XDG_DATA_HOME:-$HOME/.local/share}/tmux/resurrect")"
state_file="$(readlink -f "${res_dir}/last" 2>/dev/null || true)"
[ -n "${state_file}" ] || exit 0

# Smart pairing: find matching useropts file for this resurrect snapshot
find_matching_useropts() {
  local resurrect_file="$1"
  local resurrect_timestamp=$(echo "$resurrect_file" | grep -oE '[0-9]{8}T[0-9]{6}')
  local res_dir=$(dirname "$resurrect_file")

  # Step 1: Try exact timestamp match
  local exact="${res_dir}/tmux_resurrect_${resurrect_timestamp}.useropts.tsv"
  [ -f "$exact" ] && echo "$exact" && return 0

  # Step 2: Search forward (prefer newer - deduplicated resurrect scenario)
  while read -r newer_useropts; do
    local ts=$(echo "$newer_useropts" | grep -oE '[0-9]{8}T[0-9]{6}')
    local corresponding_resurrect="${res_dir}/tmux_resurrect_${ts}.txt"
    if [ ! -f "$corresponding_resurrect" ]; then
      # No matching resurrect = resurrect was deduplicated
      echo "$newer_useropts"
      return 0
    fi
  done < <(ls -1 "${res_dir}"/tmux_resurrect_*.useropts.tsv 2>/dev/null | \
           awk -F'[_T]' -v target="${resurrect_timestamp}" \
           '$3$4 > target' | sort)

  # Step 3: Search backward (deduplicated useropts scenario)
  while read -r older_useropts; do
    local ts=$(echo "$older_useropts" | grep -oE '[0-9]{8}T[0-9]{6}')
    local corresponding_resurrect="${res_dir}/tmux_resurrect_${ts}.txt"
    if [ ! -f "$corresponding_resurrect" ]; then
      # No matching resurrect = useropts was deduplicated
      echo "$older_useropts"
      return 0
    fi
  done < <(ls -1 "${res_dir}"/tmux_resurrect_*.useropts.tsv 2>/dev/null | \
           awk -F'[_T]' -v target="${resurrect_timestamp}" \
           '$3$4 < target' | sort -r)

  return 1  # No valid pairing found
}

sidecar=$(find_matching_useropts "$state_file")
[ -n "$sidecar" ] && [ -f "$sidecar" ] || exit 0

# Base64 decode (portable macOS/Linux)
b64d() { printf '%s' "$1" | base64 -D 2>/dev/null || printf '%s' "$1" | base64 -d; }

while IFS=$'\t' read -r scope sess win pane key vb64 cwd; do
  val="$(b64d "${vb64}" || true)"

  case "${scope}" in
    server)
      # Set server-level option (ignore errors)
      tmux set-option -gsq "${key}" "${val}" 2>/dev/null || true
      ;;

    session)
      # Set session-level option (ignore errors)
      tmux set-option -sq -t "${sess}" "${key}" "${val}" 2>/dev/null || true
      ;;

    window)
      # Set window-level option (ignore errors)
      tmux set-option -swq -t "${sess}:${win}" "${key}" "${val}" 2>/dev/null || true
      ;;

    pane)
      # Pane-level options require extra validation
      target="${sess}:${win}.${pane}"

      # 1. Check if pane exists
      if ! tmux list-panes -t "${target}" >/dev/null 2>&1; then
        continue  # Pane doesn't exist, skip silently
      fi

      # 2. Check if user option already exists (NEVER OVERWRITE)
      existing="$(tmux show -pqv -t "${target}" "${key}" 2>/dev/null || true)"
      if [ -n "${existing}" ]; then
        continue  # Skip - pane already has this option set
      fi

      # 3. Validate pane identity using CWD (skip if '-' which means no CWD was saved)
      if [ "${cwd}" != "-" ]; then
        current_cwd="$(tmux display -pt "${target}" -F '#{pane_current_path}' 2>/dev/null || true)"
        if [ "${current_cwd}" != "${cwd}" ]; then
          continue  # Skip - wrong pane (likely renumbering issue)
        fi
      fi

      # 4. Set user option (ignore errors, continue on failure)
      tmux set-option -pq -t "${target}" "${key}" "${val}" 2>/dev/null || true
      ;;
  esac
done < "${sidecar}"
